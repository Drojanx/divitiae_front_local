{
  "version": 3,
  "sources": ["../../deepmerge/dist/cjs.js", "../../flatted/cjs/index.js", "../../vuex-persist/src/MockStorage.ts", "../../vuex-persist/src/SimplePromiseQueue.ts", "../../vuex-persist/src/utils.ts", "../../vuex-persist/src/index.ts"],
  "sourcesContent": ["'use strict';\r\n\r\nvar isMergeableObject = function isMergeableObject(value) {\r\n\treturn isNonNullObject(value)\r\n\t\t&& !isSpecial(value)\r\n};\r\n\r\nfunction isNonNullObject(value) {\r\n\treturn !!value && typeof value === 'object'\r\n}\r\n\r\nfunction isSpecial(value) {\r\n\tvar stringValue = Object.prototype.toString.call(value);\r\n\r\n\treturn stringValue === '[object RegExp]'\r\n\t\t|| stringValue === '[object Date]'\r\n\t\t|| isReactElement(value)\r\n}\r\n\r\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\r\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\r\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\r\n\r\nfunction isReactElement(value) {\r\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\r\n}\r\n\r\nfunction emptyTarget(val) {\r\n\treturn Array.isArray(val) ? [] : {}\r\n}\r\n\r\nfunction cloneUnlessOtherwiseSpecified(value, options) {\r\n\treturn (options.clone !== false && options.isMergeableObject(value))\r\n\t\t? deepmerge(emptyTarget(value), value, options)\r\n\t\t: value\r\n}\r\n\r\nfunction defaultArrayMerge(target, source, options) {\r\n\treturn target.concat(source).map(function(element) {\r\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\r\n\t})\r\n}\r\n\r\nfunction getMergeFunction(key, options) {\r\n\tif (!options.customMerge) {\r\n\t\treturn deepmerge\r\n\t}\r\n\tvar customMerge = options.customMerge(key);\r\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\r\n}\r\n\r\nfunction getEnumerableOwnPropertySymbols(target) {\r\n\treturn Object.getOwnPropertySymbols\r\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\r\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\r\n\t\t})\r\n\t\t: []\r\n}\r\n\r\nfunction getKeys(target) {\r\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\r\n}\r\n\r\nfunction propertyIsOnObject(object, property) {\r\n\ttry {\r\n\t\treturn property in object\r\n\t} catch(_) {\r\n\t\treturn false\r\n\t}\r\n}\r\n\r\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\r\nfunction propertyIsUnsafe(target, key) {\r\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\r\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\r\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\r\n}\r\n\r\nfunction mergeObject(target, source, options) {\r\n\tvar destination = {};\r\n\tif (options.isMergeableObject(target)) {\r\n\t\tgetKeys(target).forEach(function(key) {\r\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\r\n\t\t});\r\n\t}\r\n\tgetKeys(source).forEach(function(key) {\r\n\t\tif (propertyIsUnsafe(target, key)) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\r\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\r\n\t\t} else {\r\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\r\n\t\t}\r\n\t});\r\n\treturn destination\r\n}\r\n\r\nfunction deepmerge(target, source, options) {\r\n\toptions = options || {};\r\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\r\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\r\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\r\n\t// implementations can use it. The caller may not replace it.\r\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\r\n\r\n\tvar sourceIsArray = Array.isArray(source);\r\n\tvar targetIsArray = Array.isArray(target);\r\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\r\n\r\n\tif (!sourceAndTargetTypesMatch) {\r\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\r\n\t} else if (sourceIsArray) {\r\n\t\treturn options.arrayMerge(target, source, options)\r\n\t} else {\r\n\t\treturn mergeObject(target, source, options)\r\n\t}\r\n}\r\n\r\ndeepmerge.all = function deepmergeAll(array, options) {\r\n\tif (!Array.isArray(array)) {\r\n\t\tthrow new Error('first argument should be an array')\r\n\t}\r\n\r\n\treturn array.reduce(function(prev, next) {\r\n\t\treturn deepmerge(prev, next, options)\r\n\t}, {})\r\n};\r\n\r\nvar deepmerge_1 = deepmerge;\r\n\r\nmodule.exports = deepmerge_1;\r\n", "'use strict';\r\n/// <reference types=\"../types/index.d.ts\" />\r\n\r\n// (c) 2020-present Andrea Giammarchi\r\n\r\nconst {parse: $parse, stringify: $stringify} = JSON;\r\nconst {keys} = Object;\r\n\r\nconst Primitive = String;   // it could be Number\r\nconst primitive = 'string'; // it could be 'number'\r\n\r\nconst ignore = {};\r\nconst object = 'object';\r\n\r\nconst noop = (_, value) => value;\r\n\r\nconst primitives = value => (\r\n  value instanceof Primitive ? Primitive(value) : value\r\n);\r\n\r\nconst Primitives = (_, value) => (\r\n  typeof value === primitive ? new Primitive(value) : value\r\n);\r\n\r\nconst revive = (input, parsed, output, $) => {\r\n  const lazy = [];\r\n  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {\r\n    const k = ke[y];\r\n    const value = output[k];\r\n    if (value instanceof Primitive) {\r\n      const tmp = input[value];\r\n      if (typeof tmp === object && !parsed.has(tmp)) {\r\n        parsed.add(tmp);\r\n        output[k] = ignore;\r\n        lazy.push({k, a: [input, parsed, tmp, $]});\r\n      }\r\n      else\r\n        output[k] = $.call(output, k, tmp);\r\n    }\r\n    else if (output[k] !== ignore)\r\n      output[k] = $.call(output, k, value);\r\n  }\r\n  for (let {length} = lazy, i = 0; i < length; i++) {\r\n    const {k, a} = lazy[i];\r\n    output[k] = $.call(output, k, revive.apply(null, a));\r\n  }\r\n  return output;\r\n};\r\n\r\nconst set = (known, input, value) => {\r\n  const index = Primitive(input.push(value) - 1);\r\n  known.set(value, index);\r\n  return index;\r\n};\r\n\r\n/**\r\n * Converts a specialized flatted string into a JS value.\r\n * @param {string} text\r\n * @param {((this: any, key: string, value: any) => any) | undefined): any} [reviver]\r\n * @returns {any}\r\n */\r\nconst parse = (text, reviver) => {\r\n  const input = $parse(text, Primitives).map(primitives);\r\n  const value = input[0];\r\n  const $ = reviver || noop;\r\n  const tmp = typeof value === object && value ?\r\n              revive(input, new Set, value, $) :\r\n              value;\r\n  return $.call({'': tmp}, '', tmp);\r\n};\r\nexports.parse = parse;\r\n\r\n/**\r\n * Converts a JS value into a specialized flatted string.\r\n * @param {any} value\r\n * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]\r\n * @param {string | number | undefined} [space]\r\n * @returns {string}\r\n */\r\nconst stringify = (value, replacer, space) => {\r\n  const $ = replacer && typeof replacer === object ?\r\n            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :\r\n            (replacer || noop);\r\n  const known = new Map;\r\n  const input = [];\r\n  const output = [];\r\n  let i = +set(known, input, $.call({'': value}, '', value));\r\n  let firstRun = !i;\r\n  while (i < input.length) {\r\n    firstRun = true;\r\n    output[i] = $stringify(input[i++], replace, space);\r\n  }\r\n  return '[' + output.join(',') + ']';\r\n  function replace(key, value) {\r\n    if (firstRun) {\r\n      firstRun = !firstRun;\r\n      return value;\r\n    }\r\n    const after = $.call(this, key, value);\r\n    switch (typeof after) {\r\n      case object:\r\n        if (after === null) return after;\r\n      case primitive:\r\n        return known.get(after) || set(known, input, after);\r\n    }\r\n    return after;\r\n  }\r\n};\r\nexports.stringify = stringify;\r\n\r\n/**\r\n * Converts a generic value into a JSON serializable object without losing recursion.\r\n * @param {any} value\r\n * @returns {any}\r\n */\r\nconst toJSON = value => $parse(stringify(value));\r\nexports.toJSON = toJSON;\r\n\r\n/**\r\n * Converts a previously serialized object with recursion into a recursive one.\r\n * @param {any} value\r\n * @returns {any}\r\n */\r\nconst fromJSON = value => parse($stringify(value));\r\nexports.fromJSON = fromJSON;\r\n", "/**\n * Created by championswimmer on 22/07/17.\n */\nlet MockStorage: typeof Storage | undefined\n\n// @ts-ignore\nif (process.env.MODULE_FORMAT !== 'umd') {\n  MockStorage = class implements Storage {\n    [index: number]: string;\n    [key: string]: any;\n\n    public get length(): number {\n      return Object.keys(this).length\n    }\n\n    public key(index: number): string | any {\n      return Object.keys(this)[index]\n    }\n\n    public setItem(key: string, data: any): void {\n      this[key] = data.toString()\n    }\n    public getItem(key: string): string {\n      return this[key]\n    }\n    public removeItem(key: string): void {\n      delete this[key]\n    }\n    public clear(): void {\n      for (let key of Object.keys(this)) {\n        delete this[key]\n      }\n    }\n  }\n}\n\nexport { MockStorage }\n", "// tslint:disable: variable-name\nexport default class SimplePromiseQueue {\n  private readonly _queue: Array<Promise<void>> = []\n  private _flushing = false\n\n  public enqueue(promise: Promise<void>) {\n    this._queue.push(promise)\n    if (!this._flushing) { return this.flushQueue() }\n    return Promise.resolve()\n  }\n\n  private flushQueue() {\n    this._flushing = true\n\n    const chain = (): Promise<void> | void => {\n      const nextTask = this._queue.shift()\n      if (nextTask) {\n        return nextTask.then(chain)\n      } else {\n        this._flushing = false\n      }\n    }\n    return Promise.resolve(chain())\n  }\n}\n", "import deepmerge from 'deepmerge'\n\nexport type MergeOptionType = 'replaceArrays' | 'concatArrays'\n\nconst options: {[k in MergeOptionType]: deepmerge.Options} = {\n  replaceArrays: {\n    arrayMerge: (destinationArray, sourceArray, options) => sourceArray\n  },\n  concatArrays: {\n    arrayMerge: (target, source, options) => target.concat(...source)\n  }\n}\n\nconst defaultMergeOptions: deepmerge.Options = {\n  // replacing arrays\n  \n}\n\nexport function merge<I, F>(into: Partial<I>, from: Partial<F>, mergeOption: MergeOptionType): I & F & {} {\n  return deepmerge(into, from, options[mergeOption])\n}\n", "/**\n * Created by championswimmer on 18/07/17.\n */\nimport { Mutation, MutationPayload, Payload, Plugin, Store } from 'vuex'\nimport { AsyncStorage } from './AsyncStorage'\nimport { MockStorage } from './MockStorage'\nimport { PersistOptions } from './PersistOptions'\nimport SimplePromiseQueue from './SimplePromiseQueue'\nimport { merge, MergeOptionType } from './utils'\n\nlet FlattedJSON = JSON\n\n/**\n * A class that implements the vuex persistence.\n * @type S type of the 'state' inside the store (default: any)\n */\nexport class VuexPersistence<S> implements PersistOptions<S> {\n  public asyncStorage: boolean\n  public storage: Storage | AsyncStorage | undefined\n  public restoreState: (key: string, storage?: AsyncStorage | Storage) => Promise<S> | S\n  public saveState: (key: string, state: {}, storage?: AsyncStorage | Storage) => Promise<void> | void\n  public reducer: (state: S) => Partial<S>\n  public key: string\n  public filter: (mutation: Payload) => boolean\n  public modules: string[]\n  public strictMode: boolean\n  public supportCircular: boolean\n  public mergeOption: MergeOptionType\n\n  /**\n   * The plugin function that can be used inside a vuex store.\n   */\n  public plugin: Plugin<S>\n  /**\n   * A mutation that can be used to restore state\n   * Helpful if we are running in strict mode\n   */\n  public RESTORE_MUTATION: Mutation<S>\n  public subscribed: boolean\n\n  // tslint:disable-next-line:variable-name\n  private _mutex = new SimplePromiseQueue()\n\n  /**\n   * Create a {@link VuexPersistence} object.\n   * Use the <code>plugin</code> function of this class as a\n   * Vuex plugin.\n   * @param {PersistOptions} options\n   */\n  public constructor(options?: PersistOptions<S>) {\n    if (typeof options === 'undefined') options = {} as PersistOptions<S>\n    this.key = ((options.key != null) ? options.key : 'vuex')\n\n    this.subscribed = false\n    this.supportCircular = options.supportCircular || false\n    if (this.supportCircular) {\n      FlattedJSON = require('flatted')\n    }\n    this.mergeOption = options.mergeOption || 'replaceArrays'\n\n    let localStorageLitmus = true\n\n    try {\n      window.localStorage.getItem('')\n    } catch (err) {\n      localStorageLitmus = false\n    }\n\n    /**\n     * 1. First, prefer storage sent in optinos\n     * 2. Otherwise, use window.localStorage if available\n     * 3. Finally, try to use MockStorage\n     * 4. None of above? Well we gotta fail.\n     */\n    if (options.storage) { this.storage = options.storage }\n    else if (localStorageLitmus) { this.storage = window.localStorage }\n    else if (MockStorage) { this.storage = new MockStorage() }\n    else { throw new Error(\"Neither 'window' is defined, nor 'MockStorage' is available\") }\n\n    /**\n     * How this works is -\n     *  1. If there is options.reducer function, we use that, if not;\n     *  2. We check options.modules;\n     *    1. If there is no options.modules array, we use entire state in reducer\n     *    2. Otherwise, we create a reducer that merges all those state modules that are\n     *        defined in the options.modules[] array\n     * @type {((state: S) => {}) | ((state: S) => S) | ((state: any) => {})}\n     */\n    this.reducer = (\n      (options.reducer != null)\n        ? options.reducer\n        : (\n          (options.modules == null)\n            ? ((state: S) => state)\n            : (\n              (state: any) =>\n                (options!.modules as string[]).reduce((a, i) =>\n                  merge(a, { [i]: state[i] }, this.mergeOption), {/* start empty accumulator*/ })\n            )\n        )\n    )\n\n    this.filter = options.filter || ((mutation) => true)\n\n    this.strictMode = options.strictMode || false\n\n    this.RESTORE_MUTATION = function RESTORE_MUTATION(state: S, savedState: any) {\n      const mergedState = merge(state, savedState || {}, this.mergeOption)\n      for (const propertyName of Object.keys(mergedState as {})) {\n        (this as any)._vm.$set(state, propertyName, (mergedState as any)[propertyName])\n      }\n    }\n\n    this.asyncStorage = options.asyncStorage || false\n\n    if (this.asyncStorage) {\n\n      /**\n       * Async {@link #VuexPersistence.restoreState} implementation\n       * @type {((key: string, storage?: Storage) =>\n       *      (Promise<S> | S)) | ((key: string, storage: AsyncStorage) => Promise<any>)}\n       */\n      this.restoreState = (\n        (options.restoreState != null)\n          ? options.restoreState\n          : ((key: string, storage: AsyncStorage) =>\n            (storage).getItem(key)\n              .then((value) =>\n                typeof value === 'string' // If string, parse, or else, just return\n                  ? (\n                    this.supportCircular\n                      ? FlattedJSON.parse(value || '{}')\n                      : JSON.parse(value || '{}')\n                  )\n                  : (value || {})\n              )\n          )\n      )\n\n      /**\n       * Async {@link #VuexPersistence.saveState} implementation\n       * @type {((key: string, state: {}, storage?: Storage) =>\n       *    (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\n       */\n      this.saveState = (\n        (options.saveState != null)\n          ? options.saveState\n          : ((key: string, state: {}, storage: AsyncStorage) =>\n            (storage).setItem(\n              key, // Second argument is state _object_ if asyc storage, stringified otherwise\n              // do not stringify the state if the storage type is async\n              (this.asyncStorage\n                ? merge({}, state || {}, this.mergeOption)\n                : (\n                  this.supportCircular\n                    ? FlattedJSON.stringify(state) as any\n                    : JSON.stringify(state) as any\n                )\n              )\n            )\n          )\n      )\n\n      /**\n       * Async version of plugin\n       * @param {Store<S>} store\n       */\n      this.plugin = (store: Store<S>) => {\n        /**\n         * For async stores, we're capturing the Promise returned\n         * by the `restoreState()` function in a `restored` property\n         * on the store itself. This would allow app developers to\n         * determine when and if the store's state has indeed been\n         * refreshed. This approach was suggested by GitHub user @hotdogee.\n         * See https://github.com/championswimmer/vuex-persist/pull/118#issuecomment-500914963\n         * @since 2.1.0\n         */\n        (store as any).restored = ((this.restoreState(this.key, this.storage)) as Promise<S>).then((savedState) => {\n          /**\n           * If in strict mode, do only via mutation\n           */\n          if (this.strictMode) {\n            store.commit('RESTORE_MUTATION', savedState)\n          } else {\n            store.replaceState(merge(store.state, savedState || {}, this.mergeOption) as S)\n          }\n          this.subscriber(store)((mutation: MutationPayload, state: S) => {\n            if (this.filter(mutation)) {\n              this._mutex.enqueue(\n                this.saveState(this.key, this.reducer(state), this.storage) as Promise<void>\n              )\n            }\n          })\n          this.subscribed = true\n        })\n      }\n    } else {\n\n      /**\n       * Sync {@link #VuexPersistence.restoreState} implementation\n       * @type {((key: string, storage?: Storage) =>\n       *    (Promise<S> | S)) | ((key: string, storage: Storage) => (any | string | {}))}\n       */\n      this.restoreState = (\n        (options.restoreState != null)\n          ? options.restoreState\n          : ((key: string, storage: Storage) => {\n            const value = (storage).getItem(key)\n            if (typeof value === 'string') {// If string, parse, or else, just return\n              return (\n                this.supportCircular\n                  ? FlattedJSON.parse(value || '{}')\n                  : JSON.parse(value || '{}')\n              )\n            } else {\n              return (value || {})\n            }\n          })\n      )\n\n      /**\n       * Sync {@link #VuexPersistence.saveState} implementation\n       * @type {((key: string, state: {}, storage?: Storage) =>\n       *     (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\n       */\n      this.saveState = (\n        (options.saveState != null)\n          ? options.saveState\n          : ((key: string, state: {}, storage: Storage) =>\n            (storage).setItem(\n              key, // Second argument is state _object_ if localforage, stringified otherwise\n              (\n                this.supportCircular\n                  ? FlattedJSON.stringify(state) as any\n                  : JSON.stringify(state) as any\n              )\n            )\n          )\n      )\n\n      /**\n       * Sync version of plugin\n       * @param {Store<S>} store\n       */\n      this.plugin = (store: Store<S>) => {\n        const savedState = this.restoreState(this.key, this.storage) as S\n\n        if (this.strictMode) {\n          store.commit('RESTORE_MUTATION', savedState)\n        } else {\n          store.replaceState(merge(store.state, savedState || {}, this.mergeOption) as S)\n        }\n\n        this.subscriber(store)((mutation: MutationPayload, state: S) => {\n          if (this.filter(mutation)) {\n            this.saveState(this.key, this.reducer(state), this.storage)\n          }\n        })\n\n        this.subscribed = true\n      }\n    }\n  }\n\n  /**\n   * Creates a subscriber on the store. automatically is used\n   * when this is used a vuex plugin. Not for manual usage.\n   * @param store\n   */\n  private subscriber = (store: Store<S>) =>\n    (handler: (mutation: MutationPayload, state: S) => any) => store.subscribe(handler)\n}\n\nexport {\n  MockStorage, AsyncStorage, PersistOptions\n}\n\nexport default VuexPersistence\n"],
  "mappings": "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",
  "names": ["isMergeableObject", "options", "deepmerge", "require_cjs", "value", "options", "deepmerge"]
}
